# Chapter 02 운영체제 개요

# 0. Introduction

- 해당 내용은 [운영체제와 정보기술의 원리  -반효경 지음-](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=) 와 [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)를 보고 정리한 내용입니다.  
- 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.

# 1. 운영체제의 정의

---

### 운영체제란?

- **_운영체제(operating system)_** 란??

  컴퓨터 하드웨어의 바로 윗단에 설치되는 소프트웨어로, 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.

<br>

### 왜 system이라 하는가???

system은 흔히들 하드웨어를 지칭할 때 주로 사용되는 단어인데, 이 system을 사용한 이유는 운영체제 없이 하드웨어만 있다면 컴퓨터 역할을 할 수 없고, OS와 하드웨어가 같이 있어야 진정한 컴퓨터이기 때문이다.

<br>

### kernel이란??

소프트웨어가 실행되기 위해서는 메모리에 그 프로그램이 올라가야 한다. 운영체제도 하나의 SW이기 때문에, 컴퓨터 하드웨어의 전원이 켜지는 동시에, 메모리에 올라간다. 이 운영체제 SW는 규모가 큰 프로그램이기 때문에, 운영체제 전부를 메모리에 올린다면 메모리 공간 낭비가 심해진다.  
 그래서 운영체제 중 **_항상 필요한 부분만_** 을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 메모리로 올려서 사용한다. **_메모리에 항상 상주하는 운영체제 부분_** 을 **_커널(kernel)_** 이라 한다. 이 커널을 **_좁은 의미의 운영체제_** 라고도 불리며, **_넓은 의미의 운영체제_** 는 utility들(ex: copy)을 광범위하게 포함하는 개념이다.

<br>

# 2. 운영체제의 기능

---

### 하드웨어 그리고 사용자를 위한 운영체제의 역할

운영체제는 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이라는 관점에서 운영체제의 기능을 생각해보면, **_하드웨어를 위한 역할_** 과 **_사용자를 위한 역할_** 로 나눠진다.  
**전자** 는 사용자를 대신하여 **_운영체제가 하드웨어인 컴퓨터 시스템 내의 resource를 효율적으로 관리하는 역할_** 을 말한다.  
 **후자** 는 **_사용자가 컴퓨터 시스템을 편리하게 사용하도록, 사용자에게 편리한 인터페이스를 제공하는 역할_** 을 말한다. 하드웨어를 직접 다루는 부분은 운영체제가 대행하여, 사용자 및 프로그램이 이에 대한 내용은 알지 못 해도 프로그램을 실행해주는 기능을 말한다.

<br>

### ❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기

운영체제의 기능은 전자와 후자 중 **_중요한 핵심기능은 바로 전자_** 다.  
 그래서 운영체제를 **_자원 관리자(resource manager)_** 라고도 부른다.
여기서 **_자원이란_** 하드웨어 자원(ex: CPU, memory, HDD) 과 소프트웨어 자원을 모두 총칭하는 말이다. 운영체제는 이 자원들을 **_효율적으로 관리_** 하여 **_가장 좋은 성능_** 을 내도록 만든다.  
 하지만, 전체적인 성능을 향상시켜려다보면 일부 프로그램 또는 사용자가 불이익을 당할 수 있다. 그래서 운영체제는 사용자 및 프로그램들 간에 자원이 **_형평성 있게 분배_** 되도록 하는 **_균형자_** 역할도 함께 수행해야 한다.

또한, 더 중요한게 사용자와 운영체제 자신을 보호하는 **_보안_** 역할을 담당한다. 악의성 프로그램으로 다른 사용자 프로그램에 접근하지 않도록 보안 및 보호 기능을 수행해야 한다.

<br>

# 3. 운영체제의 분류

---

운영체제의 분류 중 하나는 **_multi-processing system_** 과 **_single-processing system_** 이다. CPU가 2개 이상 설치되면 전자, 1개만 설치되면 후자를 말한다. 여기서 분류는 후자를 가정으로 진행된다.

운영체제의 분류에는 동시 작업을 지원하는지, 다중 사용자를 지원하는지, 실시간(real time)을 지원하는지에 따라 분류된다. 앞에서부터 차근 차근 알아보자.

<br>

### 첫 번째 분류: 동시 작업의 지원 유무

**동시 작업을 지원**하는지의 여부에 따라 **_단일작업(single tasking)용_** 운영체제와 **_다중작업(multi tasking)용_** 운영체제로 나누어볼 수 있다. 각 설명은 다음 표와 같다.

| 운영체제 분류  | 동시 작업 지원 유무  | 예시                 |
| -------------- | -------------------- | -------------------- |
| single tasking | X (한 번에 하나)     | 초창기 운영체제, DOS |
| multi-tasking  | O (동시에 창 여러개) | MS window, Unix      |

<br>

### Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system

**다중 작업 시에는 여러 프로그램이 CPU와 memory를 공유**한다.

**_CPU의 경우_**, 처리 속도가 워낙 빨라서 여러 프로그램이 CPU의 작업시간을 조금씩 나누어 번갈아 쓰지만, 사용자 입장에서는 동시 실행처럼 보인다. 이를 **_시분할 시스템(time sharing system)_** 이라 한다.

또한, **_메모리의 경우_** 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 사용한다. 이를 **_다중 프로그래밍 시스템(multi-programming system_)** 이라 한다.

다중 작업의 경우, 여러 프로그램을 같이 실행하지만, 사용자 개개인의 관점에서는 각 프로그램에 대한 입력 결과를 곧바로 화면에 보여준다. 이를 **_대화형 시스템(interactive system)_** 이라 한다. 여러 사용자가 동시 접속 하는 서버의 경우에도, 각 사용자 입장에서는 혼자 사용하는 것처럼 느끼게 해주므로 대화형 시스템에 해당된다.

<br>

### 두 번째 분류: 다중 사용자 동시지원 유무

| 운영체제 분류 | 다중 사용자 지원 | 추가 설명                  | 예시           |
| ------------- | ---------------- | -------------------------- | -------------- |
| 단일 사용자용 | X                | 한 번에 한 사용자만        | DOS, MS window |
| 다중 사용자용 | O                | 여러 사용자 동시 접속 가능 | server(서버)   |

<br>

### 세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식)

| 작업 처리 방식                    | 의미                                                             | 추가 설명               | 예                                  |
| --------------------------------- | ---------------------------------------------------------------- | ----------------------- | ----------------------------------- |
| 일괄 처리 (batch processing)      | 일정량씩 모아 한꺼번에 처리하는 방식                             | 응답 시간이 길다.       | 초창기 컴퓨터에 사용하는 punch card |
| 시분할 방식 (time sharing system) | 여러 작업을 수행 시, 일정 시간 단위로 분할해 CPU를 사용하는 방식 | 짧은 응답시간을 갖는다. | 유닉스 운영체제 하의 서버 컴퓨터    |

<br>

### 다섯 번째 분류: 실시간(real time) 운영체제

real time system은 정해진 시간 안에 처리를 보장하는 시스템에서 사용된다.

| 분류                 | 설명                                                                                  | 예                                           |
| -------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------- |
| Hard realtime system | 주어진 시간을 지키지 못할 경우, 매우 위험한 결과를 초래할 가능성 O                    | 원자로, 공장 제어 시스템, 미사일 제어 시스템 |
| Soft realtime system | 데이터가 정해진 시간 단위로 되어야 올바른 기능을 수행할 수 있는 시스템. 위험한 결과 X | 멀티 미디어 스트링                           |

<br>

# 4. 운영체제의 예

---

MS Window와 Unix의 예를 통해 간단히 살펴보자.

MS Window는 마이크로소프트에서 이전에 개발한 MS-DOS와 WINDOW 3.1을 발전시킨, 개인용 컴퓨터를 위한 운영체제다.

마이크로소프트가 기존에 발표한 MS-DOS는 초보자가 사용하기 어려운 명령어 입력 방식을 지녔기 때문에, 좀 더 쉬운 사용을 위해 윈도우를 개발했다.

그리고, WINDOW 3.1은 grapic interface와 mouse 기능을 지원하는 점에서 사용자에게 편리한 환경을 제공했지만, 독자적인 운영체제가 되지 못하고 MS-DOS 위에 수행된다는 점에서 여러 한계점을 가지고 있었다. 예를 들어 컴퓨터 시스템을 완전히 제어할 수 없는 것, 불안정하다는 것 그리고, WINDOW를 사용하면서도 DOS를 함께 사용해야 하는 부가적인 어려움이 있었다.

그 이후 온전한 운영체제가 된 것이 윈도우 95다. 윈도우 XP부터는 인터페이스측면에서 그래픽 환경과 아이콘 방식을 기본적으로 채택하면서, 다양한 방식으로 지원해 자신에게 편한 방법으로 다룰 수 있게 했다.

MS Window의 또 다른 큰 특징은 **plug and play**다. 시스템에 새로운 하드웨어를 장착하면 OS가 자동으로 감지하여, 새로운 하드웨어에 맞게 설정된다는 점이다.

그러면 MS Window와 Unix를 비교해보겠다.

**_이식성(protability)_** 이란?

해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표

|        | MS Window                           | Unix                                                                      |
| ------ | ----------------------------------- | ------------------------------------------------------------------------- |
| 대상   | 누구든지 손쉽게 사용(개인용 컴퓨터) | 프로그램 개발 환경을 위해 설계된 OS, 오랜 전통, 대형 컴퓨터,전문적인 목적 |
| 특징 1 | 편리한 인터페이스                   | 이식성(protability)이 좋음                                                |
| 특징 2 | 안정성 낮음                         | 안정성이 좋음                                                             |
| 특징 3 |                                     | kernel의 크기가 작음                                                      |
| 특징 4 |                                     | souce code 공개됨 → 실제 연구에 이바지                                    |
| 특징 5 |                                     | 스스로 꾸밀 수 있음                                                       |
| 특징 6 |                                     | 후에 GUI 제공됨                                                           |

<br>

# 5. 운영체제의 자원 관리 기능

---

자원이란 하드웨어 자원과 소프트웨어 자원을 포함한다고 했다. 이번 소단원에서는 하드웨어 자원을 어떻게 관리하는지 알아보자.

하드웨어 자원에는 CPU, 메모리, 그리고 입출력 장치들로 구성된다.

<br>

## CPU 관리 기법: 3가지

**_CPU_** 란 Central Processing Unit의 약자로, 명령어를 실행하는 연산 장치를 말한다. 이 **_CPU_** 는 통상적으로 **컴퓨터 한 대에 하나**가 장착되기 때문에, 여러 프로세스들이 CPU를 **효율적으로** 나누어 사용할 수 있도록 관리되어야 한다. 이 **CPU의 대표적인 관리 방법** 에는 **선입선출(First Come First Served: FCFS), 라운드 로빈(Round Robin), 우선순위(Priority) 기법**이 있다.

<br>

### CPU 관리 기법 첫 번째: 선입선출(FCFS)

CPU를 사용하기 위해 먼저 온 process를 먼저 처리하는 방식이 **_선입선출_** 이다. 일상생활에서 줄을 서서 기다리는 것과 동일하다. 이 방법의 단점은 CPU를 필요로 하는 process가 여러 개 있을 때, CPU를 먼저 얻은 process가 원하는 작업을 완료할 때까지 다른 프로세스들은 CPU를 사용하지 못한다는 점이다. **_CPU 자체의 효율적인 측면에서는 문제 없지만, 전체 시스템의 관점에서는 비효율적인 결과를 초래할 수 있다._** 장시간 이용해야 하는 프로세스가 먼저 오고, 그 뒤에 단시간 이용해야하는 프로세스가 올 경우 단시간 이용하면 되지만, 먼저 온 프로세스로 인해 계속 대기해야하는 상황이 발생된다.

<br>

### CPU 관리 기법 두 번째: 라운드 로빈(Round Robin)

위 선입선출의 단점을 보완하여 나온 방법이 **_라운드 로빈(Round Robin)_** 이다. 이 방법은 **_CPU를 한 번 할당 받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한_** 한다. 각 프로세스는 이 정해진 시간 동안에만 CPU를 할당받는다. 작업이 완료되지 않았어도, 시간이 끝나면 CPU를 내려놓고, CPU 대기열의 제일 뒤에 가서 줄을 서야 한다. 먼저 온 프로세스의 작업 완료 시간이 길어도, 계속해서 기다릴 문제가 발생되지 않는다. 각 process마다 이 정해진 시간만큼 보장받을 수 있다.

<br>

### **CPU 관리 기법 세 번째: 우선순위(Priority)**

대기 중인 프로세스들에게 우선순위를 부여하고, **_우선순위가 높은 process들에게 먼저 CPU를 할당_** 한다. 먼저 와서 CPU를 기다릴지라도, 우선순위에 따라 융통성 있게 process들에게 CPU를 할당할 수 있다. 또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다리는 시간에 비례하여 우선순위를 점차 높여주는 방안도 활용된다.

<br>

## Memory란??

또 다른 중요 관리 대상으로 Memory가 있다. **_메모리_** 역시 CPU처럼 **한정된 용량**만 존재하기 때문에, 서로 다른 다수의 프로세스들이 **나누어** 쓸 수 있도록 해야 한다. **메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부 기억장치**다. 프로그램이 CPU에서 실행될라면 해당 부분이 메모리에 올라가 있어야 한다. 메모리는 한정된 용량을 가지고 있기 때문에, **효율적인 관리**를 위해 운영체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 **주소(address)** 를 통해 관리된다.

<br>

### 운영체제가 Memory 관리가 필요한 이유

프로세스와 메모리의 관계는 다음과 같다. 추가적으로 할당하여 프로세스가 **빨리 수행**될 수 있지만, 메모리 **자원을 낭비**하는 경우도 발생한다. **운영체제는 프로그램에 메모리가 필요할 때 할당하고, 필요하지 않으면 메모리를 회수한다.** 따라서 운영체제는 전체 메모리 공간이 **효율적으로 사용될 수 있도록 잘 판단**해야 한다. 또한, 각 프로세스가 **자신의 메모리 영역에만 접근**할 수 있도록 보안 관리를 잘 해야 한다.

<br>

### Memory 관리 방식 3가지

memory 관리 방식에는 **고정 분할(fixed partition) 방식, 가변 분할(variable partition) 방식, 가상 메모리(virtual memory) 방식**이 있다. 각 방식에 대해 알아보자.

<br>

### Memory 관리 방식 첫 번째: 고정 분할 방식

고정 분할 방식은 명칭 그대로 물리적 메모리를 미리 고정된 크기로 나누어 관리한다. 이로 인해 몇 가지 단점이 있다.

첫 번째, 프로그램 크기에 맞게 융통성 있게 할당할 수가 없다는 문제점이 있다.

두 번째, 고정된 크기이기 때문에 최대 할당할 수 있는 프로그램의 수가 정해져 있다.

세 번째, 나눠진 메모리 크기보다 큰 프로그램은 적재가 불가능하다.

네 번째, 나눠진 크기보다 작은 프로그램에 할당하면 **분할 내에 남는 영역** 이 발생한다. 이 영역을 **내부 조각(internal fragmentation)** 이라 한다. 이 영역은 올라온 프로그램에 의해서도 사용될 수 없고, 다른 프로그램에 할당할 수 없어서 **비효율적으로 낭비되는 공간** 이다.

<br>

### Memory 관리 방식 두 번째: 가변 분할 방식

가변 분할 방식은 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다. 이 방식 또한 전체 물리적 메모리 크기보다 큰 프로그램에는 여전히 할당할 수 없다. 그리고, 고정 분할 방식의 내부 조각은 발생되지 않지만, **외부 조각(external fragmentation)** 이 발생할 수 있다. 외부조각이란 프로그램에 할당되지는 않았지만, 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다. 그래서 비효율적으로 낭비되는 공간이다.

<br>

### Memory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법

현대 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이 기법에서 실행될 수 있는 프로그램의 크기는 물리적 메모리가 아닌 **가상 메모리 크기에 의해 결정**된다. 그래서 **물리적 메모리보다 큰 프로그램도 지원**할 수 있다.

모든 프로그램은 물리적 메모리와 독립적으로 가상 메모리를 가지고 있다. 운영체제는 이 가상 메모리의 주소를 물리적 메모리의 주소로 **mapping (전환, 연결)하는 기술**을 사용하여 전환 후, 물리적 메모리에 올린다.

예를 드어보자.

가상 메모리 기법을 사용하여 현재 물리적 메모리보다 더 큰 메모리를 요구하는 프로그램을 실행한다고 하자. 각 프로그램은 전체가 동시에 사용되는 게 아니다. 그러므로 사용되고 있는 부분만 물리적 메모리에 올리고, 나머지는 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식으로 큰 프로그램을 사용할 수 있다. 이 때, 사용되는 보조기억장치의 영역을 **스왑 영역(swap area)** 라고 부른다. 프로그램을 구성하는 가상 메모리 공간은 **페이징(paging) 기법**을 사용하여 저장된다.

<br>

## 입출력 장치 관리 기법

이 CPU와 메모리는 전원이 꺼지면 처리 중이던 정보가 모두 지워지기 때문에, **_보조기억장치_** 에 파일 형태로 저장한다. 이 보조기억장치의 예로는 하드디스크가 있으며, 그 외에는 키보드, 마우스, 모니터 등이 **_입출력 장치_** 로 OS 관리 대상에 포함된다. 입출력 장치 관리는 **_인터룹트(interrupt)_** 를 통해 이뤄진다.

<br>

### Interrupt mechanism

CPU는 CPU schedulling에 따라 주어진 작업을 수행하다가, 주변 입출력 장치로의 controller가 CPU에게 인터룹트를 발생시키면 CPU는 자신이 하던 작업을 중단한다. 그리고 현재 자신이 하던 작업 상태를 저장한다. 왜냐하면 다시 중단된 작업을 이어서 해야하기 때문이다. 이 인터룹트가 발생된 순간, CPU의 사용권은 프로그램에서 운영체제로 넘어온다. 그러면, 운영체제는 kernel에 발생된 인터룹트의 종류에 맞는 인터룹트 처리루틴을 찾아서 처리루틴에 기록된 코드에 따라 일을 처리한다. 그 후, 다시 중단되 업무에 CPU는 복귀한다. controller란 입출력 장치가 가지고 있는 sub CPU라 생각하자.

<br>

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
