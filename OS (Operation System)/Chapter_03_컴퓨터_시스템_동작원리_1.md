# Chapter 03 컴퓨터 시스템의 동작원리 - 1

# 0. Introduction

> 1. [컴퓨터 시스템의 구조](#1-컴퓨터-시스템의-구조)
> 2. [CPU 연산과 I/O 연산](#2-cpu-연산과-io-연산)
> 3. [인터럽트의 일반적 기능](#3-인터럽트의-일반적-기능)
> 4. [인터럽트 핸들링](#4-인터럽트-핸들링interrupt-handling)

- 해당 내용은 [운영체제와 정보기술의 원리 -반효경 지음-](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=) 와 [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)를 보고 정리한 내용입니다.
- 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.

<br>

---

# 1. 컴퓨터 시스템의 구조

<br>

## 1.1 컴퓨터의 구조: 내부장치와 외부장치

- 컴퓨터 시스템의 구조 = **_컴퓨터 내부장치_** + **_컴퓨터 외부장치_**
  - **_컴퓨터 내부장치_** : CPU, Memory
  - **_컴퓨터 외부장치_** : Disk, keyboard, mouse, monitor, network device 등

## 1.2 컴퓨터의 업무 처리 방식

- 컴퓨터 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 연산 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.
- 이때, 업무의 각 부분을 다음과 같이 정의한다.
  - **_입력(input):_** 컴퓨터 내부로 데이터가 들어오는 것
  - **_출력(output):_** 컴퓨터 외부장치로 데이터가 나가는 것
    - **_입출력(Input-output: I/O): 컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고 받는 것_**
  - 예시)
    - 키보드로부터 입력을 받아 컴퓨터가 연산을 한 후, 그 결과를 모니터에 출력
    - 컴퓨터 외부장치인 디스크에서 내용을 읽어 컴퓨터 내부에 연산을 한 후, 디스크에 데이터를 저장.

## 1.3 Controller: 각 하드웨어 장치의 작은 CPU

- 컴퓨터 전체에 CPU(Cetnral Processing Unit)라는 중앙처리장치가 있듯이, 컴퓨터의 각 하드웨어 장치에는 이들을 제어하는 일종의 작은 CPU인 **_컨트롤러_** 가 있다.
- 예)
  - 메모리를 제어하는 컨트롤러는 메모리 컨트롤러
  - 디스크를 제어하는 컨트롤러는 디스크 컨트롤러

<br>

---

# 2. CPU 연산과 I/O 연산

<br>

## 2.1 연산 = CPU가 무언가를 한다

- 컴퓨터에서 **연산**을 한다 = **_CPU가 무언가 일을 한다_**
- 컴퓨터의 구성장치 관점에서 연산을 나눠 보자면 다음과 같이 담당한다.
  - 입출력 장치들의 I/O 연산 → 입출력 컨트롤러가 담당
  - 컴퓨터 내에서 수행되는 연산 → main CPU
  - 이 때 입출력 장치와 main CPU는 일이 다른 곳에서 발생하므로 동시 수행이 가능하다.

## 2.2 Local Buffer(로컬 버퍼)

- 각 장치 컨트롤러는 장치로부터 오고 나가는 데이터를 **임시 저장** 하기 위한 작은 메모리인 **_로컬 버퍼(local buffer)_** 가 존재한다.
- 입력 장치로부터 데이터를 읽어오는 경우, 각 입력장치의 컨트롤러가 장치에서 로컬버퍼로 데이터를 읽어와서 저장 후, 컴퓨터 내부의 메모리에 전달한다.

## 2.3 CPU와 I/O 장치의 연산과정

1. 프로그램에서 데이터를 읽어오라는 명령을 내린다 →
2. 각 장치의 컨트롤러가 장치로부터 내용을 읽어 로컬버퍼에 저장한다 →
3. 데이터를 읽는 작업을 완료했기 때문에, 메인 CPU에서 I/O 작업을 요청한 프로그램의 다음 일을 수행할 수 있다. HW 또는 SW는 CPU 옆에 **_인터룹트 라인(interrup line)_** 을 세팅하는 명령을 실행하여, 컨트롤러가 **_인터룹트(interrupt)_** 를 발생시켜 메인 CPU에게 I/O작업이 완료됨을 알린다 →

- 인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법

4. CPU는 **_명령 하나를 수행할 때마다_** 인터룹트가 발생했는지 확인하는데, 인터럽트가 발생하면 자신이 하던 일을 멈추고, **_인터럽트 처리를 먼저 한 후_** 멈춘 명령을 다시 수행한다.

<br>

---

# 3. 인터럽트의 일반적 기능

<br>

## 3.1 Interrupt(인터럽트)란??

- 인터럽트(Interrupt)란 **CPU의 제어권을 양도하라는 신호**
- 사용자 프로그램에게 CPU 제어권이 있어서, CPU를 사용하고 있다가 interrupt를 발생시키면 kernel에게 CPU가 이양된다.

- 오늘날 **_운영체제가 CPU를 점유하는 건 인터럽트에 의하지 않고는 발생하지 않는다._**
  - 운영체제는 단지 인터럽트가 발생할 때에만 CPU의 제어권을 획득할 수 있는데,
  - 인터럽트가 발생하지 않으면 사용자 프로그램이 계속 CPU를 점유한다.

## 3.2 인터럽트 처리루틴이란???

- 인터럽트를 당한 시점의 레지스터와 program counter를 저장한 후, CPU 제어를 인터럽트 처리 루틴에 넘긴다.
- **_인터럽트 처리루틴(Interrupt Service Routine)_** 이란?
  - **_해당 인터럽트를 처리하는 커널 함수_**
  - 인터럽트 핸들러(interrupt handler) 라고도 한다.
  - 다양한 controller가 있는 만큼 interrupt의 종류도 다양하다.
  - 그러므로 인터럽트 처리루틴의 종류도 다양하다.
- **_인터럽트 벡터(interrupt vector)_**
  - **_해당 인터럽트의 처리 루틴 주소를 가리킨다._**
- 인터럽트 처리루틴까지의 과정
  - 컨트롤러가 인터럽트를 발생시키면 CPU는 인터럽트 라인을 통해 인터럽트 발생을 확인하고, 자신이 하던 일을 멈춘다.  
    -> 프로그램의 실행 상태를 PCB에 저장한 후, CPU의 제어권은 프로세스에서 운영체제로 넘어간다.  
    -> 그리고, 운영체제는 interrupt vector가 가리키는 곳으로 가서 인터럽트 처리루틴을 찾는다.  
    -> 인터럽트 처리루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면, CPU는 PCB로부터 CPU 상에 복원하여 인터럽트 당하기 직전의 위치부터 계속 수행.

## 3.3 Interrupt line

- 특정 프로그램이 CPU를 독점하는 걸 방지하기 위해서 **_timer_** 라는 HW를 사용하여, timer의 시간이 다 되면 **_interrupt line_** 을 통해 interrupt를 건다.
- 또한, controller가 I/O 작업을 완료하면 interrupt line을 통해 interrupt를 건다.

## 3.4 인터럽트의 종류: HW interrupt 와 SW interrupt

- Interrupt = HW interrupt + SW interrupt
- HW interrupt
  - HW가 발생시킨 인터럽트
  - HW 일꾼들이 CPU와 정보 교신을 위해서 거는 것
  - **하드웨어 장치**가 CPU의 interrupt line을 세팅한다.
  - 통상적으로 불리는 interrupt의 의미가 HW interrupt다.
- SW interrupt (= **_트랩(trap)_**)
  - 사용자 프로그램이 운영체제에게 대행해달라고 요청하는 것
  - **소프트웨어**가 CPU의 interrupt line을 세팅한다.
  - Trap의 종류: **_예외 상황(exception)_** 과 **_시스템 콜(system call)_**
- HW interrupt와 SW interrupt의 공통점
  - CPU 옆 인터럽트 라인에 신호를 보내 인터럽트 발생유무를 알리는 방식은 동일하다.

## 3.5 Trap: exception 과 system call

<br>

### 3.5.1 예외 상황(exception)

> **_비정상적인 작업 또는, 권한이 없는 작업을 시도할 때, 이에 대한 처리를 위해 발생시키는 인터럽트_**

- 비정상적인 작업의 예: 사용자 프로그램이 0으로 나누는 연산을 실행
- 권한이 없는 작업의 예: 사용자 프로그램이 자신의 메모리 영역 바깥에 접근하려는 시도

<br>

### 3.5.2 시스템 콜(system call)

> **_사용자 프로그램이 운영체제 내부에 정의된 코드를 실행할 때, 운영체제에게 서비스를 요청하는 방법_**

- 사용자 프로그램의 코드는 사용자 프로그램이 CPU에 대한 제어권을 가지고 실행한다.
- 하지만, 커널 내부에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 사용자 프로그램이 직접 접근할 수 있는 게 아니라, system call을 통해서 **_대행 요청_** 을 한다.
- system call 요청을 interrupt line 을 통해 CPU 제어권을 운영체제로 넘겨 커널 내부 코드를 실행한다.

<br>

---

# 4. 인터럽트 핸들링(Interrupt handling)

## 4.1 Interrupt handling 이란??

> **_인터럽트가 발생한 경우에 처리해야할 일의 절차_**

- 프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 **_프로그램 A의 현재 상태를 먼저 저장_** 한다.

  - 현재 상태란? 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다.

- 현재 상태를 먼저 저장하는 이유는??
  - CPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다.
  - 그런데, **_인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지므로_** , CPU 내의 이러한 상태를 저장해둬야 한다.

## 4.2 PCB(Process Control Block)이란??

> **_OS가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조로 PCB(Process Control Block, 프로세스 제어 블록)라 한다._**

- **_PCB_** 는
  - 각각의 **_프로그램마다 하나씩 존재_** 한다.
  - **_해당 프로그램의 어느 부분이 실행 중이었는지를 저장_** 한다.
    - ex) 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등
- **_PCB 사용절차_**
  - Interrupt 발생 → **_CPU의 제어권을 넘기기 전에 프로그램의 실행 상태를 PCB에 저장_** → CPU의 제어권이 OS로 넘어간다 → 운영체제는 인터럽트 벡터가 가리키는 곳으로 가서 인터럽트 처리루틴에 따라 인터럽트 처리를 수행→ 인터럽트 처리 완료 → 저장된 상태를 PCB로부터 CPU 상에 복원 → 인터럽트 당하기 직전 위치부터 재실행

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
- [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)
