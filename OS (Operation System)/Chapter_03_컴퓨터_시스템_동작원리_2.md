# Chapter 03 컴퓨터 시스템의 동작원리 - 下

# 0. Introduction

> 5. [입출력 구조](#5-입출력-구조)
> 6. [DMA](#6-dma)
> 7. [저장장치의 구조](#7-저장장치의-구조)
> 8. [저장장치의 계층 구조](#8-저장장치의-계층-구조)
> 9. [하드웨어의 보안](#9-하드웨어의-보안)
> 10. [메모리 보안](#10-메모리-보안)
> 11. [CPU 보호](#11-cpu-보호)
> 12. [시스템 콜을 이용한 입출력 수행](#12-시스템-콜을-이용한-입출력-수행)

- 해당 내용은 [운영체제와 정보기술의 원리 -반효경 지음-](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=) 와 [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)를 보고 정리한 내용입니다.
- 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.

<br>

---

# 5. 입출력 구조

- CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 상대적으로 느리다.
- 이 입출력 방식에는 **_동기식 입출력_** 과 **_비동기식 입출력_** 이 있다.

## 5.1 동기식 입출력(Synchronous I/O)

- 일반적으로 사용하는 방식
- 어떤 프로그램이 입출력했을 때, **_입출력 작업이 완료된 후에야_** 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.
  - 예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 **_동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다_**. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다.
- 동기식 입출력 과정

  A process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다  
   → A는 CPU에게 system call이라는 SW interrupt를 발생  
   → CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다  
   → CPU의 제어권이 운영체제에게 넘어간다  
   → A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 + 운영체제는 인터럽트 처리루틴 수행  
   → CPU는 컨트롤러에게 입출력 연산을 요청  
   → 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다  
   → 컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다  
   → 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 하드웨어 인터럽트다  
   → 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리  
   → 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시켜 A에게 CPU를 할당  
   → A는 CPU를 기다리는 줄에 다시 선다  
   → 다시 B로 돌아와 업무를 계속 진행  
   → A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행

### 5. 1.1 **입출력 연산 동안 CPU를 다른 process에게 할당하는 이유** : **CPU 낭비 방지**

- 기본 지식 1: **_입출력 연산 속도는 CPU 연산 속도보다 매우 느리다._**
- 기본 지식 2: 매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다.
  - 하지만, 동기화는 자동적으로 이뤄진다.
- _입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 언터럽트를 기다리며 아무런 일을 하지 못한다._
- _그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다._
- **_예시_**  
  _프로세스 A가 CPU를 할당받고, 명령을 수행하다가 입출력 요청을 한다._
  → 그러면 CPU를 다른 프로세스 B에게 할당한다.  
  → 프로세스 B가 CPU를 할당받아 명령을 수행하고, 프로세스 A는 입출력 작업을 수행한다.  
  → 프로세스 A가 입출력 작업을 완료할 때까지 CPU를 프로세스 A에게 할당 안한다.  
  → 또한, CPU를 프로세스 A에게 할당해도 명령을 수행하지 못하도록 봉쇄한다.  
  → 프로세스 A가 입출력 작업을 완료 후, 연산 완료의 통보로서 인터럽트를 보내야 CPU가 프로세스 A가 할당된다.

- **입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유**
  - 입출력 중인 프로그램의 상태를 **_봉쇄 상태(Bblocked state)_** 로 전환하기 때문
  - 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다.
  - 인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.

### 5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유: 동기성 보장=동기화

- _입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다._
- _그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다._
- 예시
  - 프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다.

### 5.1.3 Summary

- 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없기 때문에, CPU가 낭비된다.
- 그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다.
- 그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다.

## 5.2 비동기식 입출력(Asynchronous I/O)

- I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 즉시 제어가 사용자 프로그램에 넘어간다.
- 그래서 입출력 연산과 무관한 처리 가능한 작업부터 처리한다.

<br>

---

# 6. DMA

- **_DMA( Direct Memory Access)_** 란??
  - CPU의 중재 없이 device controller가 device의 buffer stroage의 내용을 메모리에 block 단위로 직접 복사한 후, CPU에 interrupt를 발생시키는 장치
- **_왜 DMA가 필요한가???_**
  - Interrupt가 발생하면 CPU가 controller의 local buffer와 memory 사이에서 데이터를 옮기는 일을 수행한다.
  - 만약 사용자 프로그램이 CPU를 사용하는 중에 I/O 장치가 interrupt를 많이 걸면, CPU가 많은 방해를 받아 CPU 효율이 많이 떨어진다.
  - 그래서 DMA가 CPU를 대신하여 local buffer에서 메모리로 읽어오는 작업을 수행한다.
  - 또한, CPU는 바이트(byte) 단위로 읽어오는데 **byte가 아닌 block이라는 큰 단위로 정보를 메모리로 읽어온 후에** CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알리기 때문에, **인터럽트의 빈도를 줄인다.**
  - 이에 대한 궁극적인 효과로 CPU를 효율적으로 관리하고, 입출력 연산을 빠르게 수행할 수 있다.
- **_그래서 CPU와 DMA만 memory에 접근할 수 있다._**

<br>

---

# 7. 저장장치의 구조

- **_저장장치_** = 주기억장치 + 보조기억장치
- **_주기억장치_** = 메모리 = RAM with 휘발성(volatile)
- **_보조기억장치_** = 마그네틱 디스크 with 비휘발성(non-volatile)
  - ex) 마그네틱 디스크(하드디스크), 플래시 메모리, CD, 마그네틱 테이프
  - 보조기억장치의 용도 = file system용 + swap area용
    - file system용:
      - 비휘발성 성질을 이용하여 전원이 나가도 유지해야할 정보를 파일형태로 저장하는 용도
    - **swap area**용:
      - 메모리 한계로 메모리 연장 용도로 사용.
      - 프로그램 수행에 필요한 부분만 메모리에 올려놓고(process), 그렇지 않은 부분은 swap area에 내려놓는다.
      - swap area에 내려놓는 일을 **swap out(스왑 아웃)** 이라 한다.
      - 비휘발성으로 사용되는 file system용과 구분
- **_하드디스크의 물리적 구조_**
  - 여러 개의 **마그네틱 원판**들이 회전축에 붙어있고,
  - 원판의 표면은 **track**으로 나눠지고,
  - 각 track은 **sector**로 나눠지며, 이 sector에 **최소한의 단위 정보**가 저장된다.
  - Arm assembly에 연결된 arm이 움직이면서 head가 저장된 데이터를 읽고 쓴다.

<br>

---

# 8. 저장장치의 계층 구조

- 컴퓨터 시스템의 저장장치 계층 구조는 다음과 같다.
  - 위로 올라갈수록 속도는 빨라지고, 가격은 비싸지고, 용량은 적어진다.

<p align="center"> <image src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdPTp8O%2Fbtrp5zc8nw9%2FjmnWtXtTRsEsMEIexcbwy1%2Fimg.png"/></p>

- **_저장장치 = Primary(주기억장치) + Secondary(보조기억장치)_**
- **_Primary_**
  - 적은 용량, 빠른 속도, 비싼 가격
    - CPU는 한 clock 당 한 instruction이 걸리지만, Main memory는 10 clock 당 한 instruction이 걸린다. 그래서 그 중간의 완충으로 cache memory를 둔다.
  - 당장 필요한 정보
  - 구성: 휘발성 저장장치로 구성되어, 전원이 나가면 그 내용이 사라진다.
    - 최상위 CPU 내부에 존재하는 register부터 cache memory, main memory 등
- **_Secondary_**
  - 많은 용량, 느린 속도, 저렴한 가격
  - 당장 필요하지 않은 정보
  - 구성: 비휘발성 저장장치로 구성되어, 전원이 나가도 지워지지 않는다.
- **_Caching_**: copying information into faster storage system
  - 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적인 기법
  - 상대적으로 ‘느린 저장장치’ 에 있는 내용 중 당장 필요한 것만 ‘빠른 저장장치’ 에 `선별적으로 저장` 하여 두 저장장치의 속도를 완충시킨다.
  - 프로그램을 구성하는 모든 부분이 균일하게 사용되는 게 아니라, 일부분만 집중적으로 사용되기 때문에 적은 용량으로도 효과를 거둔다.


# 9. 하드웨어의 보안

- _하드웨어의 보안이 필요한 이유??_
  - OS는 multi-programming 환경에서 동작하기 때문에, 프로그램 간에 충돌이나, 다른 프로그램의 실행을 방해할 수 있기 때문.
- _Solution: 보조 장치 Mode bit 사용_
  - **Mode bit** 을 통해 하드웨어적으로 두 가지 모드의 **operation** 지원
  - _Mode bit == 0: kernel mode_
    - 운영체제가 CPU를 수행하는 mode
    - **모든 종류의 명령** 실행 가능
    - 보안을 해칠 수 있는 중요 명령어는 `특권명령` 으로 규정
    - 모든 I/O 명령은 `특권명령`이므로, kernel mode에서 실행
    - interrupt가 드어오면 mode bit는 0으로 setting
  - _Mode bit == 1: user mode_
    - 사용자 프로그램이 CPU를 수행하는 mode
    - 자신의 메모리 영역 주소만 보고 수행하여, 모든 기계어 실행을 막는다.
    - 사용자가 무한 루프로 CPU를 사용할 경우에도 timer가 있기 때문에 CPU 독점 사용 방지가능
    - 운영체제가 CPU 제어권을 사용자 프로그램에게 넘길 때 mode bit를 1로 세팅하여 넘긴다.
- _전환 mechanism_
  - CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit가 0인지 확인한다.
  - 입출력 명령도 보안 관련 명령이므로, 사용자 프로그램이 입출력을 직접 할 수 없고, 운영체제가 한다.
  - 그래서, 사용자 프로그램이 입출력 작업을 하고 싶으면 sw interrupt인 system call을 CPU에 걸어서 운영체제가 CPU를 할당 받고, interrupt vector가 가리키는 위치를 통해 interrupt service routine으로 이동한다.
  - sw interrupt를 거는 순간 mode bit 는 1에서 0으로 세팅되어 입출력 명령을 수행할 수 있다.

<p align="center"> <image src ="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6ff5565-3556-4fb4-a5cd-ed4048744fff/kernel_mode.png"/></p>

<br>

---

# 10. 메모리 보안

- 메모리 보안이 필요한 이유??
  - 메모리에 여러 프로그램들이 동시에 올라와 실행되기 때문에, 한 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다.
  - 그래서 프로세스가 합법적인 메모리 범위에 있는지 체크하는 방법을 사용한다.
- **_Solution: 기준 레지스터(base register) + 한계 레지스터(limit register)_**
  - **기준 레지스터(base register)**
    - 어떤 프로그램이 수행하는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다.
  - **한계 레지스터(limit register)**
    - 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관
- **_이 Solution을 어떻게 사용하는가???_**
  - 사용자 프로그램이 base register + limit register 값을 벗어나는 주소에 접근하면 **불법적인 메모리 접근이므로, SW interrupt인 exception을 발생**시킨다.
  - 그래서 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 예외상황을 발생시킨 프로그램을 강제로 종료시킨다.
- 메모리 보안에서 특권명령
  - 기준 레지스터와 한계 레지스터의 **값을 세팅하는 연산**은 **특권명령**으로 규정.
  - **메모리 접근 연산**은 사용자 프로그램이 CPU를 가지고 있는 동안 수행되므로 특권명령이 아니다.
- kernel mode와 user mode의 메모리 접근 차이
  - kernel mode: 메모리에 무제한 접근 가능
  - user mode: base register와 limit register를 사용해서 메모리를 보호

<p align="center"> <image src ="https://images.velog.io/images/jehjong/post/2393e5ae-7318-4b41-8879-da6d2cfc0df1/image.png"/></p>

<br>

---

# 11. CPU 보호

- CPU의 독점 사용을 방지하기 위해 **Timer(타이머) 라는 하드웨어**를 사용한다.
  - 사용자 프로그램이 CPU를 보유하고 있다가 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘어가도록 interrupt를 발생시키는 하드웨어
  - 매 clock tick 때마다 1씩 감소하다가, 0이 되면 interrupt가 발생한다.
- timer의 값을 setting하는 명령을 **_load timer_** 라 하며, `특권 명령` 이다.
- timer는 시분할 시스템을 구현하기 위해서도 사용된다.

<br>

---

# 12. 시스템 콜을 이용한 입출력 수행

- 모든 입출력(I/O) 명령은 특권 명령(kernel 영역)에 해당한다.
- 그러면 사용자 프로그램은 어떻게 I/O를 하는가??
  - system call이라는 SW interrupt를 사용하여 운영체제에게 I/O 서비스 대행 요청을 한다.
  - 그러면 제어권이 사용자 프로그램에서 운영체제로 넘어간다.
  - 그리고, 운영체제는 인터럽트 처리 루틴을 실행한다.
  - 입출력 완료 시, 제어권을 사용자 프로그램에게 넘긴다.

<br>

---

<br>

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
- [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)
