거의 정렬된 상태의 정수 배열이 주어졌다고 가정합시다.
불필요한 비교를 최소화하도록 최적화된 버블 정렬을 구현해보는 게 핵심인 문제입니다.
일반적인 버블 정렬은 배열이 이미 정렬되어 있어도 모든 패스를 수행하겠지만,
이 문제에서는 순회를 할 떄마다 교환(swap)이 한 번도 일어나지 않으면 그 시점에서 정렬을 조기에 종료해야 합니다.

이렇게 하면 이미 대부분 정렬된 데이터에 대해서는 효율적으로 작동할 수 있습니다.
프로그램은 버블 정렬을 수행하면서 실제로 몇 번의 패스를 수행했는지를 계산하고
최종적으로 정렬된 배열과 함께 수행한 패스의 횟수를 출력해야합니다.
그러면 데이터가 거의 정렬된 경우 얼마나 비교/교환을 줄였는지 확인할 수 있겠지요.

해당 문제를 해보는 이유 : 이 문제는 기본 버블 정렬에서 한 단계 더 나아가 최적화 개념을 도입해야 합니다.
초보자는 단순한 2중 루프를 구현하는 것에는 익숙할 수 있지만,
여기에 정렬 완료 여부를 체크하는 논리를 추가하는 데에서 어려움을 겪을 수 있기 때문이죠.
지금 해보려는 흐름 제어는 코드를 조금 더 복잡해지긴 할 것이고,
올바르게 구현하지 못하면 일부 경우에 정렬이 완료되지 않거나 반대로 비교를 충분히 하지 못하는 상황이 발생할 수 있습니다.
그렇기에 최적화 로직을 정확히 이해하고 구현해야 하고 이는 어느 정도의 프로그래밍적 사고를 요구합니다.

입력
• 첫째 줄에 정수 N이 주어집니다. (1 ≤ N ≤ 1000)
• 둘째 줄에 N개의 정수가 주어집니다. (배열의 초기 상태)
• 배열은 거의 정렬되어 있어서, 일부 원소들만 잘못된 위치에 있다고 가정합니다.
출력
• 첫째 줄에 모든 원소를 오름차순으로 정렬한 결과를 공백으로 구분하여 출력합니다.
• 둘째 줄에는 "Passes: X" 형식으로, 버블 정렬 알고리즘이 종료되기까지 수행한 패스 횟수 X를 출력합니다.
예제 입력:
5
1 2 4 3 5

예제 출력:
1 2 3 4 5
Passes: 2

(위 예시에서 배열 [1, 2, 4, 3, 5]는 거의 정렬된 상태이며, 1회 패스 후에도 정렬이 완료되지 않아 2회 패스를 수행한 후 정렬이 완료되었습니다.
총 2회의 패스로 정렬을 끝마쳤으니 Passes: 2를 출력합니다.)
제약 조건:
• 1 ≤ N ≤ 1000
• 입력 배열의 값 범위: -10^5 ≤ 값 ≤ 10^5 (정수)
• 정렬은 버블 정렬로 구현해야 하며, 내부적으로 Arrays.sort()등의 사용은 금지됩니다.
• 최적화 이전의 버블 정렬은 최악의 경우 O(N^2) 시간이 걸리지만, 최적화 적용 시 최선의 경우 O(N)에 종료될 수 있습니다. N=1000까지는 충분히 처리 가능합니다.


