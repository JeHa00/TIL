정수 N개로 이루어진 배열과 정수 K가 주어졌다고 가정할게요~
버블 정렬을 최대 K번의 패스까지만 수행한 뒤 그 결과 배열을 출력하는 프로그램을 작성해보죠.
여기서 1번의 패스는 버블 정렬에서 배열을 처음부터 끝까지 한 바퀴 훑으며
필요한 교환을 수행하는 과정을 의미합니다.
만약 K번의 패스를 모두 수행하기 전에 배열이 완전히 정렬되면 그때 정렬을 종료합니다.
이 문제에서는 제한된 연산만으로 얼마나 정렬을 진행시킬 수 있는지 확인하는 것이 핵심입니다.
그러니까 역순으로 정렬된 배열 [6, 5, 4, 3, 2, 1]에 대해 K=2인 경우,
2번의 패스를 수행하면 배열의 끝에서부터 2개의 원소는 제자리로 정렬되지만
전체 배열은 아직 정렬되지 않은 상태로 남습니다. 이때의 결과 배열을 출력해야 합니다.

이 문제를 풀이해보는 이유 :
이 문제는 버블 정렬 알고리즘의 수행 과정을 깊이 이해해야 풀 수 있어요.
초보자에게는 제한된 횟수만큼만 정렬을 수행한다는 개념이 생소할 수 있겠죠.
일반적으로 정렬 알고리즘은 완료될 때까지 돌기 때문에 중간 단계를 출력하도록 제어하는 것은 난이도가 있는 편이라고 볼 수 있습니다.
특히 버블 정렬은 매 패스마다 가장 큰 값이 배열 끝에 정착한다는 특성이 있습니다.
이를 이해하면 K 패스 후에는 뒤쪽 K개의 요소가 정렬 완료된 상태임을 알 수 있지만,
초보자는 이런 이론적인 기반 없이 단순 구현에 치중할 수 있거든요.
이 문제는 전반적으로, 알고리즘 제어 흐름을 다루는 훈련이 되는 문제라고 볼 수 있습니다.

입력
• 첫째 줄에 정수 N과 K가 주어집니다. (0 ≤ K ≤ N-1, 1 ≤ N ≤ 1000)
• 둘째 줄에 N개의 정수가 주어집니다. (배열의 초기 값들)
출력
• 버블 정렬을 최대 K번 패스 수행한 후의 배열 상태를 한 줄에 공백으로 구분하여 출력합니다. (정렬이 완전히 끝나지 않았으면 부분 정렬된 상태가 출력됨)
입력
6 2
6 5 4 3 2 1
출력
4 3 2 1 5 6

(역순 배열 [6,5,4,3,2,1]에 대해 2번의 버블 정렬 패스를 수행한 결과입니다.
1회 패스를 마치면 가장 큰 값 6이 맨 끝으로 이동하고, 2회 패스를 마치면 그 다음 큰 값 5가 끝에서 두 번째 위치로 이동하죠.
 따라서 결과 배열의 마지막 두 원소 [5,6]는 정렬되었지만 나머지는 아직 부분적으로만 정렬된 상태라고 볼 수 있습니다.)

제약 조건:
• 1 ≤ N ≤ 1000
• 0 ≤ K ≤ N-1 (K=0인 경우 배열을 전혀 정렬하지 않고 그대로 출력하며, K ≥ N-1인 경우 충분한 패스를 수행하여 배열이 완전히 정렬됩니다.)
• 시간 복잡도: 최악의 경우 K=N-1에 가까울 때 O(N^2)에 수렴하지만, K가 작을 경우 그보다 훨씬 적은 연산만 수행합니다. N=1000, K=1000 정도는 문제 없이 처리 가능합니다.
• 추가 메모리 사용은 배열 자체 외에 필요 없으며, 정렬 과정에서 일부 임시 변수(교환용) 정도만 사용합니다.