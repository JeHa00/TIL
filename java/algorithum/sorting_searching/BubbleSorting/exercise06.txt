N개의 정수로 이루어진 배열과 목표 합계 값 T가 주어졌을 때,
배열을 먼저 버블 정렬로 오름차순 정렬한 후 두 원소의 합이 T가 되는 한 쌍을 찾아 출력하는 프로그램을 작성해보겠습니다.
정렬을 수행하면서 두 수의 합을 찾는 과정을 최적화할 수 있습니다.
배열이 정렬된 후에는 왼쪽 끝과 오른쪽 끝에서부터 두 개의 포인터를 움직여가며 합을 검사하는 등의 방법으로
빠르게 쌍을 찾을 수 있겠죠. 원하는 출력은 조건을 만족하는 두 수의 값입니다.
만약 그런 쌍이 존재하지 않는다면 뭔가 메시지를 출력해야겠죠.
그니까 입력 배열이 [2, 11, 7, 15, 4, 3]이고 T=9인 경우라면
정렬된 배열 [2, 3, 4, 7, 11, 15]에서 합이 9가 되는 쌍은 (2, 7)등이 있으며 그 중 하나인 2와 7을 출력하면 되겠습니다.

이 문제를 풀어보는 이유 : 이 문제는 정렬과 탐색이라는 두 가지 단계를 결합해야 하기때문에
복합적인 사고가 필요한 과정이라고 볼 수 있습니다.
초보자라면 먼저 배열을 정렬한 다음, 정렬된 배열에서 두 수를 찾는 두 단계로 접근해야 하는데,
단계별로 실수할 수 있는 요소가 꽤 있다고 볼 수 있죠.
버블 정렬 구현에서 실수를 하면 이후 단계가 잘못되고, 정렬 후 두 수를 찾는 부분에서는 다음을 고려해야 할 것입니다.

이 문제에서는 한 쌍을 찾으면 되니까 발견하면 출력을 하고 종료하면 되지만 우리는 언제 종료해야 할지 판단해야 합니다.
그리고 쌍이 없는 경우를 놓치지 않고 처리해야 할 테고 이 또한 조건문 처리가 필요할것입니다.
전체적으로 두 알고리즘을 차례로 구현하고 논리를 연결해야 하기때문에 어떻게 보면 우리에게는 충분히 도전적인 문제라고 볼 수 있겠네요.

입력
• 첫째 줄에 정수 N이 주어집니다. (1 ≤ N ≤ 1000)
• 둘째 줄에 N개의 정수가 주어집니다. (배열 요소들)
• 셋째 줄에 정수 T가 주어집니다. (목표 합 값)
출력
• 합이 T가 되는 두 개의 값을 공백으로 구분해 출력합니다. (작은 값 먼저 출력해도 무방함)
• 만약 조건을 만족하는 쌍이 존재하지 않으면 NO PAIR와 같은 메시지를 출력합니다.
예제
6
2 11 7 15 4 3
9

예제
2 7

(정렬된 배열 [2, 3, 4, 7, 11, 15]에서 2와 7의 합이 9가 되므로, 해당 쌍을 출력한 예시입니다.)

제약
• 1 ≤ N ≤ 1000
• -10000 ≤ 배열 원소 값 ≤ 10000, -20000 ≤ T ≤ 20000 (음수 합도 찾아야 할 수 있음)
• 시간 복잡도: 버블 정렬 O(N^2)과 두 수 찾기 O(N) (투 포인터 이용 시) 혹은 O(N^2) (중첩 루프 이용 시). N=1000까지는 최악 O(10^6) 연산으로 충분히 처리 가능합니다.
• 동일한 원소를 두 번 사용하는 것은 불가 (인덱스가 다른 두 개의 원소를 사용해야 함). 배열에 중복 값이 있을 수 있지만, 같은 인덱스의 원소를 중복으로 쓸 수 없다는 의미입니다.